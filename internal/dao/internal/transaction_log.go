// ==========================================================================
// Code generated by GoFrame CLI tool. DO NOT EDIT.
// ==========================================================================

package internal

import (
	"OnchainParser/internal/chain/ethEvm/consts"
	"OnchainParser/internal/model"
	"bytes"
	"context"
	"github.com/gogf/gf/v2/database/gdb"
	"github.com/gogf/gf/v2/frame/g"
	"strconv"
	"strings"
)

// TransactionLogDao is the data access object for table TransactionLog.
type TransactionLogDao struct {
	table   string                // table is the underlying table name of the DAO.
	group   string                // group is the database configuration group name of current DAO.
	columns TransactionLogColumns // columns contains all the column names of Table for convenient usage.
}

// TransactionLogColumns defines and stores column names for table TransactionLog.
type TransactionLogColumns struct {
	Removed    string // 是否已移除
	LogIndex   string // index
	TxHash     string // 当前交易的哈希值
	BlockHash  string // 当前区块的哈希值
	Height     string // 区块号
	Address    string // 签名数据，用于页面展示
	Data       string // log data
	Type       string // type
	Topics     string // topics，Array<String>类型
	UpdateTime string // 修改时间(时间戳)
}

// transactionLogColumns holds the columns for table TransactionLog.
var transactionLogColumns = TransactionLogColumns{
	Removed:    "removed",
	LogIndex:   "log_index",
	TxHash:     "tx_hash",
	BlockHash:  "block_hash",
	Height:     "height",
	Address:    "address",
	Data:       "data",
	Type:       "type",
	Topics:     "topics",
	UpdateTime: "update_time",
}

// NewTransactionLogDao creates and returns a new DAO object for table data access.
func NewTransactionLogDao() *TransactionLogDao {
	return &TransactionLogDao{
		group:   "default",
		table:   "transaction_log",
		columns: transactionLogColumns,
	}
}

// DB retrieves and returns the underlying raw database management object of current DAO.
func (dao *TransactionLogDao) DB() gdb.DB {
	return g.DB(dao.group)
}

// Table returns the table name of current dao.
func (dao *TransactionLogDao) Table() string {
	return dao.table
}

// Columns returns all column names of current dao.
func (dao *TransactionLogDao) Columns() TransactionLogColumns {
	return dao.columns
}

// Group returns the configuration group name of database of current dao.
func (dao *TransactionLogDao) Group() string {
	return dao.group
}

func (dao *TransactionLogDao) Ctx(ctx context.Context) *gdb.Model {
	return dao.DB().Model(dao.table).Safe().Ctx(ctx)
}

// Ctx creates and returns the Model for current DAO, It automatically sets the context for current operation.
func (dao *TransactionLogDao) CtxWithDatabase(ctx context.Context, database string) *gdb.Model {
	return dao.DB().Model(database + "." + dao.table).Safe().Ctx(ctx)
}

func (dao *TransactionLogDao) Transaction(ctx context.Context, f func(ctx context.Context, tx *gdb.TX) error) (err error) {
	return dao.Ctx(ctx).Transaction(ctx, f)
}

func (dao *TransactionLogDao) QueryExistsByTxHashAndIndex(ctx context.Context, txHash string, logIndex int32, chainName string) (exists bool, err error) {
	key := chainName + "_" + consts.TRANSACTION_LOG_DATA_KEY + txHash + "_" + strconv.FormatInt(int64(logIndex), 10)
	v, err := g.Redis().Do(ctx, "GET", key)
	if err == nil && !g.IsEmpty(v) {
		return v.Bool(), nil
	}
	return false, err
}

func (dao *TransactionLogDao) ExecInsert(ctx context.Context, in model.TransactionLogCreateInput, chainName string) (err error) {
	var dimSqlDML bytes.Buffer
	dimSqlDML.WriteString("insert into ")
	dimSqlDML.WriteString(chainName + "." + dao.table)
	dimSqlDML.WriteString(" (removed,log_index,tx_hash,block_hash,height,address,data,type,topics,update_time) values ( ")
	dimSqlDML.WriteString(strconv.FormatBool(in.Removed))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.LogIndex), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString("'" + in.TxHash + "'")
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString("'" + in.BlockHash + "'")
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.Height), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString("'" + in.Address + "'")
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString("'" + in.Data + "'")
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString("'" + in.Type + "'")
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString("'" + strings.Join(in.Topics, ",") + "'")
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.UpdateTime), 10))
	dimSqlDML.WriteString(")")

	_, err = dao.DB().Exec(ctx, dimSqlDML.String())
	if err != nil {
		g.Log().Debug(ctx, "TransactionLogDao ExecInsert error:", err, ", TxHash:", in.TxHash, ",LogIndex:", in.LogIndex)
		return err
	}

	key := chainName + "_" + consts.TRANSACTION_LOG_DATA_KEY + in.TxHash + "_" + strconv.FormatInt(int64(in.LogIndex), 10)
	g.Redis().Do(ctx, "SETEX", key, 300, true)

	return
}

func (dao *TransactionLogDao) ExecBatchInsert(ctx context.Context, ins []model.TransactionLogCreateInput, chainName string) (err error) {
	var dimSqlDML bytes.Buffer
	dimSqlDML.WriteString("insert into ")
	dimSqlDML.WriteString(chainName + "." + dao.table)
	dimSqlDML.WriteString(" (removed,log_index,tx_hash,block_hash,height,address,data,type,topics,update_time) values ")

	for i := 0; i < len(ins); i++ {
		in := ins[i]
		if !g.IsEmpty(in.TxHash) {
			dimSqlDML.WriteString("(")
			dimSqlDML.WriteString(strconv.FormatBool(in.Removed))
			dimSqlDML.WriteString(",")
			dimSqlDML.WriteString(strconv.FormatInt(int64(in.LogIndex), 10))
			dimSqlDML.WriteString(",")
			dimSqlDML.WriteString("'" + in.TxHash + "'")
			dimSqlDML.WriteString(",")
			dimSqlDML.WriteString("'" + in.BlockHash + "'")
			dimSqlDML.WriteString(",")
			dimSqlDML.WriteString(strconv.FormatInt(int64(in.Height), 10))
			dimSqlDML.WriteString(",")
			dimSqlDML.WriteString("'" + in.Address + "'")
			dimSqlDML.WriteString(",")
			dimSqlDML.WriteString("'" + in.Data + "'")
			dimSqlDML.WriteString(",")
			dimSqlDML.WriteString("'" + in.Type + "'")
			dimSqlDML.WriteString(",")
			dimSqlDML.WriteString("'" + strings.Join(in.Topics, ",") + "'")
			dimSqlDML.WriteString(",")
			dimSqlDML.WriteString(strconv.FormatInt(int64(in.UpdateTime), 10))
			dimSqlDML.WriteString(")")

			if i != len(ins)-1 {
				dimSqlDML.WriteString(",")
			}

			key := chainName + "_" + consts.TRANSACTION_LOG_DATA_KEY + in.TxHash + "_" + strconv.FormatInt(int64(in.LogIndex), 10)
			g.Redis().Do(ctx, "SETEX", key, 300, true)
		}
	}

	_, err = dao.DB().Exec(ctx, dimSqlDML.String())
	if err != nil {
		g.Log().Debug(ctx, "TransactionLogDao ExecInsert error:", err, ", TxLogsLen:", len(ins))
		return err
	}
	return
}
