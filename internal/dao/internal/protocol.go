// ==========================================================================
// Code generated by GoFrame CLI tool. DO NOT EDIT.
// ==========================================================================

package internal

import (
	"OnchainParser/internal/chain/ethEvm/consts"
	"OnchainParser/internal/model"
	"OnchainParser/internal/model/entity"
	"bytes"
	"context"
	"github.com/gogf/gf/v2/database/gdb"
	"github.com/gogf/gf/v2/errors/gerror"
	"github.com/gogf/gf/v2/frame/g"
	"strconv"
)

// ProtocolDao is the data access object for table protocol.
type ProtocolDao struct {
	table   string          // table is the underlying table name of the DAO.
	group   string          // group is the database configuration group name of current DAO.
	columns ProtocolColumns // columns contains all the column names of Table for convenient usage.
}

// ProtocolColumns defines and stores column names for table protocol.
type ProtocolColumns struct {
	ProtocolCode string // 编码，如pancakeswap
	ProtocolName string // 名称，如PancakeSwap
	IsValid      string // 是否有效, 1:有效；0:无效
	UpdateTime   string // 修改时间(时间戳)
}

// protocolColumns holds the columns for table protocol.
var protocolColumns = ProtocolColumns{
	ProtocolCode: "protocol_code",
	ProtocolName: "protocol_name",
	IsValid:      "is_valid",
	UpdateTime:   "update_time",
}

// NewProtocolDao creates and returns a new DAO object for table data access.
func NewProtocolDao() *ProtocolDao {
	return &ProtocolDao{
		group:   "default",
		table:   "protocol",
		columns: protocolColumns,
	}
}

// DB retrieves and returns the underlying raw database management object of current DAO.
func (dao *ProtocolDao) DB() gdb.DB {
	return g.DB(dao.group)
}

// Table returns the table name of current dao.
func (dao *ProtocolDao) Table() string {
	return dao.table
}

// Columns returns all column names of current dao.
func (dao *ProtocolDao) Columns() ProtocolColumns {
	return dao.columns
}

// Group returns the configuration group name of database of current dao.
func (dao *ProtocolDao) Group() string {
	return dao.group
}

// Ctx creates and returns the Model for current DAO, It automatically sets the context for current operation.
func (dao *ProtocolDao) Ctx(ctx context.Context) *gdb.Model {
	return dao.DB().Model(dao.table).Safe().Ctx(ctx)
}

// Ctx creates and returns the Model for current DAO, It automatically sets the context for current operation.
func (dao *ProtocolDao) CtxWithDatabase(ctx context.Context, database string) *gdb.Model {
	return dao.DB().Model(database + "." + dao.table).Safe().Ctx(ctx)
}

// Transaction wraps the transaction logic using function f.
// It rollbacks the transaction and returns the error from function f if it returns non-nil error.
// It commits the transaction and returns nil if function f returns nil.
//
// Note that, you should not Commit or Rollback the transaction in function f
// as it is automatically handled by this function.
func (dao *ProtocolDao) Transaction(ctx context.Context, f func(ctx context.Context, tx *gdb.TX) error) (err error) {
	return dao.Ctx(ctx).Transaction(ctx, f)
}

func (dao *ProtocolDao) DeleteByProtocolCode(ctx context.Context, protocolCode string, chainName string) (err error) {
	v, err := dao.QueryOneByProtocolCode(ctx, protocolCode, chainName)
	if err != nil {
		return err
	}

	if g.IsEmpty(v.ProtocolCode) {
		return gerror.New("the protocolCode is not exist")
	}

	_, err = dao.CtxWithDatabase(ctx, chainName).Delete("protocol_code=?", protocolCode)
	if err != nil {
		g.Log().Debug(ctx, "Contract DeleteByProtocolCode error , ", err)
		return err
	}
	//查询时从数据库重新拉取数据
	g.Redis().Do(ctx, "DEL", chainName+"_"+consts.PROTOCOL_VALID_LIST_DATA_KEY)
	return nil
}

func (dao *ProtocolDao) UpdateValid(ctx context.Context, protocolCode string, isVaild bool, chainName string) (err error) {
	_, err = dao.CtxWithDatabase(ctx, chainName).Update("is_valid=?", "protocol_code=?", strconv.FormatBool(isVaild), protocolCode)
	if err != nil {
		g.Log().Debug(ctx, "Contract UpdateValid error , ", err)
		return err
	}
	//查询时从数据库重新拉取数据
	g.Redis().Do(ctx, "DEL", chainName+"_"+consts.PROTOCOL_VALID_LIST_DATA_KEY)
	return
}

func (dao *ProtocolDao) QueryOneByProtocolCode(ctx context.Context, protocolCode string, chainName string) (rcd entity.ProtocolEntity, err error) {
	var res []entity.ProtocolEntity
	//添加protocol时使用，频率不高，不使用缓存
	err = dao.CtxWithDatabase(ctx, chainName).Where("protocol_code =?", protocolCode).Scan(&res)
	if err != nil {
		g.Log().Debug(ctx, "QueryOneByProtocolCode error:", err)
		return rcd, err
	}

	if res != nil && len(res) > 0 {
		return res[0], nil
	} else {
		return rcd, nil
	}
}

func (dao *ProtocolDao) QueryEnableList(ctx context.Context, chainName string) (result []entity.ProtocolEntity, err error) {
	key := chainName + "_" + consts.PROTOCOL_VALID_LIST_DATA_KEY
	v, err := g.Redis().Do(ctx, "GET", key)
	if err == nil {
		serr := v.Struct(&result)
		if serr == nil && len(result) > 0 {
			return result, nil
		}
	}

	err = dao.CtxWithDatabase(ctx, chainName).Where("is_valid =?", true).Scan(&result)
	if err != nil {
		g.Log().Debug(ctx, "QueryEnableList error:", err)
		return nil, err
	}

	// 设置缓存过期时间10天
	g.Redis().Do(ctx, "SETEX", key, 3600*24, result)
	return result, nil
}

func (dao *ProtocolDao) QueryList(ctx context.Context, protocolCode string, isValid string, chainName string) (result []entity.ProtocolEntity, err error) {
	var dataModel *gdb.Model
	dataModel = dao.CtxWithDatabase(ctx, chainName)
	wBuild := dataModel.Builder()

	if !g.IsEmpty(protocolCode) {
		wBuild = wBuild.Where("protocol_code =?", protocolCode)
	}
	if !g.IsEmpty(isValid) {
		status := false
		if isValid == "1" {
			status = true
		}
		wBuild = wBuild.Where("is_valid =?", status)
	}
	wBuild = wBuild.Where("1=1") // 上述条件都不满足，where 需要一个默认条件
	err = dataModel.Where(wBuild).OrderDesc("update_time").Scan(&result)
	if err != nil {
		g.Log().Debug(ctx, "QueryList error:", err)
		return nil, err
	}
	return result, nil
}

func (dao *ProtocolDao) ToAuditList(ctx context.Context, chainName string) (result []entity.ProtocolEntity, err error) {
	err = dao.CtxWithDatabase(ctx, chainName).Where("is_valid =?", false).Scan(&result)
	if err != nil {
		g.Log().Debug(ctx, "ToAuditList error:", err)
		return nil, err
	}
	return result, nil
}

func (dao *ProtocolDao) ExecInsert(ctx context.Context, chainName string, in model.ProtocolCreateInput) (err error) {
	var dimSqlDML bytes.Buffer
	dimSqlDML.WriteString("insert into ")
	dimSqlDML.WriteString(chainName + "." + dao.table)
	dimSqlDML.WriteString(" (protocol_code, protocol_name, is_valid, update_time) values ( ")
	dimSqlDML.WriteString("'" + in.ProtocolCode + "'")
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString("'" + in.ProtocolName + "'")
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatBool(in.IsValid))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.UpdateTime), 10))
	dimSqlDML.WriteString(")")

	_, err = dao.DB().Exec(ctx, dimSqlDML.String())
	if err != nil {
		return err
	}

	//查询时从数据库重新拉取数据
	g.Redis().Do(ctx, "DEL", chainName+"_"+consts.PROTOCOL_VALID_LIST_DATA_KEY)
	return
}
