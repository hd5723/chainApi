// ==========================================================================
// Code generated by GoFrame CLI tool. DO NOT EDIT.
// ==========================================================================

package internal

import (
	"OnchainParser/internal/chain/ethEvm/consts"
	"OnchainParser/internal/model"
	"OnchainParser/internal/model/entity"
	"bytes"
	"context"
	"encoding/json"
	_ "github.com/gogf/gf/contrib/drivers/clickhouse/v2"
	"github.com/gogf/gf/v2/database/gdb"
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/os/gfile"
	"strconv"
)

var (
	TempPath        = gfile.Pwd() + "/sql/trs_temp.sql"
	BatchInsertPath = gfile.Pwd() + "/sql/trs_batchInsert.sql"
)

// TransactionDao is the data access object for table Transaction.
type TransactionDao struct {
	table   string             // table is the underlying table name of the DAO.
	group   string             // group is the database configuration group name of current DAO.
	columns TransactionColumns // columns contains all the column names of Table for convenient usage.
}

// TransactionColumns defines and stores column names for table Transaction.
type TransactionColumns struct {
	TxHash          string // 当前交易的哈希值
	TxIndex         string // 当前交易的下标
	Height          string // 区块号
	ContractAddress string // 合约地址
	Status          string // 交易状态 <失败|成功>
	From            string // 交易发起者的地址
	To              string // 交易接收者的地址
	Value           string // 交易金额
	GasUsed         string // 燃料费
	GasLimit        string // the gas limit in jager
	GasPrice        string // the gas price in jager
	TransactionFee  string // Amount paid to the miner for processing the transaction.
	CreateTime      string // 创建时间(时间戳)
	UpdateTime      string // 修改时间(时间戳)
	Timestamp       string // 修改时间(时间戳)
}

// transactionColumns holds the columns for table Transaction.
var transactionColumns = TransactionColumns{
	TxHash:          "tx_hash",
	TxIndex:         "tx_index",
	Height:          "height",
	ContractAddress: "contract_address",
	Status:          "status",
	From:            "from",
	To:              "to",
	Value:           "value",
	GasUsed:         "gas_used",
	GasLimit:        "gas_limit",
	GasPrice:        "gas_price",
	TransactionFee:  "transaction_fee",
	CreateTime:      "create_time",
	UpdateTime:      "update_time",
	Timestamp:       "timestamp",
}

// NewTransactionDao creates and returns a new DAO object for table data access.
func NewTransactionDao() *TransactionDao {
	return &TransactionDao{
		group:   "default",
		table:   "transaction",
		columns: transactionColumns,
	}
}

func (dao *TransactionDao) GetTempPath() string {
	return TempPath
}

func (dao *TransactionDao) GetBatchInsertPath() string {
	return BatchInsertPath
}

// DB retrieves and returns the underlying raw database management object of current DAO.
func (dao *TransactionDao) DB() gdb.DB {
	//conn, err := gdb.New(gdb.ConfigNode{
	//	Link: "clickhouse://default:password@127.0.0.1:9000/chainData?dial_timeout=200ms&max_execution_time=60",
	//	Type: "clickhouse",
	//})
	//if err != nil {
	//	panic(err)
	//}
	//return conn
	return g.DB(dao.group)
}

// Table returns the table name of current dao.
func (dao *TransactionDao) Table() string {
	return dao.table
}

// Columns returns all column names of current dao.
func (dao *TransactionDao) Columns() TransactionColumns {
	return dao.columns
}

// Group returns the configuration group name of database of current dao.
func (dao *TransactionDao) Group() string {
	return dao.group
}

func (dao *TransactionDao) Ctx(ctx context.Context) *gdb.Model {
	return dao.DB().Model(dao.table).Safe().Ctx(ctx)
}

// Ctx creates and returns the Model for current DAO, It automatically sets the context for current operation.
func (dao *TransactionDao) CtxWithDatabase(ctx context.Context, database string) *gdb.Model {
	return dao.DB().Model(database + "." + dao.table).Safe().Ctx(ctx)
}

func (dao *TransactionDao) Transaction(ctx context.Context, f func(ctx context.Context, tx *gdb.TX) error) (err error) {
	return dao.Ctx(ctx).Transaction(ctx, f)
}

func (dao *TransactionDao) QueryExistsByTxHash(ctx context.Context, txHash string, chainName string) (exists bool, err error) {
	key := chainName + "_tx_" + txHash
	v, err := g.Redis().Do(ctx, "GET", key)
	if err == nil && !g.IsEmpty(v) {
		return v.Bool(), nil
	}
	return false, err
}

func (dao *TransactionDao) QueryOneByTxHash(ctx context.Context, txHash string, chainName string) (result entity.TransactionEntity, err error) {
	temp, err := dao.CtxWithDatabase(ctx, chainName).Where("tx_hash =?", txHash).One()
	if err != nil {
		return result, err
	}
	json.Unmarshal([]byte(temp.Json()), &result)
	return result, nil
}

func (dao *TransactionDao) QueryOneByAddressAndTxHash(ctx context.Context, contractAddress string, txHash string, chainName string) (result entity.TransactionEntity, err error) {
	temp, err := dao.CtxWithDatabase(ctx, chainName).Where("tx_hash =?", txHash).Where("contract_address =?", contractAddress).One()
	if err != nil {
		return result, err
	}
	json.Unmarshal([]byte(temp.Json()), &result)
	return result, nil
}

func (dao *TransactionDao) QueryListByAddress(ctx context.Context, contractAddress string, pageSize int, pageNumber int, chainName string) (result []entity.TransactionEntity, err error) {
	if g.IsEmpty(pageSize) {
		pageSize = 50
	}
	if g.IsEmpty(pageNumber) {
		pageNumber = 1
	}
	limitBegin := pageSize * (pageNumber - 1)
	temp, err := dao.CtxWithDatabase(ctx, chainName).Where("contract_address =?", contractAddress).OrderDesc("timestamp").Limit(limitBegin, pageSize).All()
	if err != nil {
		g.Log().Debug(ctx, "QueryListByAddress error:", err)
		return nil, err
	}
	json.Unmarshal([]byte(temp.Json()), &result)
	return result, nil
}

func (dao *TransactionDao) QueryListByTime(ctx context.Context, contractAddress string, blockBeginTime string, blockEndTime string, address string, pageSize int, pageNumber int, chainName string) (result []entity.TransactionEntity, err error) {
	var temp gdb.Result
	if g.IsEmpty(pageSize) {
		pageSize = 50
	}
	if g.IsEmpty(pageNumber) {
		pageNumber = 1
	}
	limitBegin := pageSize * (pageNumber - 1)
	var dataModel *gdb.Model
	dataModel = dao.CtxWithDatabase(ctx, chainName)
	wBuild := dataModel.Builder()

	if !g.IsEmpty(contractAddress) {
		wBuild = wBuild.Where("contract_address =?", contractAddress)
	}
	if !g.IsEmpty(address) {
		wBuild = wBuild.Where("from=?", address)
	}
	if !g.IsEmpty(blockBeginTime) {
		wBuild = wBuild.WhereGTE("timestamp", blockBeginTime)
	}
	if !g.IsEmpty(blockEndTime) {
		wBuild = wBuild.WhereLTE("timestamp", blockEndTime)
	}
	wBuild = wBuild.Where("1=1") // 上述条件都不满足，where 需要一个默认条件
	temp, err = dataModel.Where(wBuild).OrderDesc("height").Limit(limitBegin, pageSize).All()

	if err != nil {
		g.Log().Debug(ctx, "QueryListByTime error:", err)
		return nil, err
	}
	json.Unmarshal([]byte(temp.Json()), &result)
	return result, nil
}

func (dao *TransactionDao) QueryByAddressAndBlockNumber(ctx context.Context, contractAddress string, blockNumer int, pageSize int, pageNumber int, chainName string) (result []entity.TransactionEntity, err error) {
	var contracts []entity.TransactionEntity
	if g.IsEmpty(pageSize) {
		pageSize = 50
	}
	if g.IsEmpty(pageNumber) {
		pageNumber = 1
	}
	limitBegin := pageSize * (pageNumber - 1)
	temp, err := dao.CtxWithDatabase(ctx, chainName).Where("height =?", blockNumer).Where("contract_address =?", contractAddress).OrderDesc("timestamp").Limit(limitBegin, pageSize).All()
	if err != nil {
		g.Log().Debug(ctx, "QueryByAddressAndBlockNumber error:", err)
		return contracts, err
	}
	json.Unmarshal([]byte(temp.Json()), &result)
	return result, nil
}

func (dao *TransactionDao) QueryLteListByGasPrice(ctx context.Context, chainName string) (result []entity.TransactionEntity, err error) {
	temp, err := dao.CtxWithDatabase(ctx, chainName).WhereLTE("gas_price", 0).All()
	if err != nil {
		g.Log().Debug(ctx, "QueryLteListByGas_price error:", err)
		return nil, err
	}
	json.Unmarshal([]byte(temp.Json()), &result)
	return result, nil
}

func (dao *TransactionDao) UpdateGasprice(ctx context.Context, txHash string, gasPrice int64, chainName string) (err error) {
	_, err = dao.CtxWithDatabase(ctx, chainName).Update("gas_price=?  ", "tx_hash=?  ", gasPrice, txHash)
	if err != nil {
		g.Log().Debug(ctx, "TransactionDao UpdateGasprice error:", err, ",txHash:", txHash)
		return err
	}
	return nil
}

func (dao *TransactionDao) ExecInsert(ctx context.Context, in model.TransactionCreateInput, chainName string) (err error) {
	var dimSqlDML bytes.Buffer
	dimSqlDML.WriteString("insert into ")
	dimSqlDML.WriteString(chainName + "." + dao.table)
	dimSqlDML.WriteString(" (tx_hash, tx_index,height,contract_address,status,from,to,value,gas_used,gas_limit,gas_price,transaction_fee,create_time,update_time,timestamp) values ( ")
	dimSqlDML.WriteString("'" + in.TxHash + "'")
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.TxIndex), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.Height), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString("'" + in.ContractAddress + "'")
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.Status), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString("'" + in.From + "'")
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString("'" + in.To + "'")
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(in.Value, 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.GasUsed), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.GasLimit), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.GasPrice), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(in.TransactionFee, 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.CreateTime), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.UpdateTime), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.Timestamp), 10))
	dimSqlDML.WriteString(")")

	_, err = dao.DB().Exec(ctx, dimSqlDML.String())
	if err != nil {
		g.Log().Debug(ctx, "TransactionDao ExecInsert error:", err, ",TxHash:", in.TxHash, ",Height:", in.Height)
		return err
	}
	simpleTxCacheKey := chainName + "_tx_" + in.TxHash
	g.Redis().Do(ctx, "SETEX", simpleTxCacheKey, 300, true)

	return
}

func (dao *TransactionDao) ExecInsertSql(ctx context.Context, in model.TransactionCreateInput, chainName string) (err error) {
	var dimSqlDML bytes.Buffer
	dimSqlDML.WriteString("(")
	dimSqlDML.WriteString("'" + in.TxHash + "'")
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.TxIndex), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.Height), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString("'" + in.ContractAddress + "'")
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.Status), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString("'" + in.From + "'")
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString("'" + in.To + "'")
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(in.Value, 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.GasUsed), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.GasLimit), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.GasPrice), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(in.TransactionFee, 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.CreateTime), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.UpdateTime), 10))
	dimSqlDML.WriteString(",")
	dimSqlDML.WriteString(strconv.FormatInt(int64(in.Timestamp), 10))
	dimSqlDML.WriteString(")")

	// 待执行的Value放在缓存里
	key := chainName + consts.BATCH_TRANSACTION_DATA_KEY
	_, err = g.Redis().Do(ctx, "HSET", key, in.TxHash, dimSqlDML.String())
	if err != nil {
		return err
	}
	g.Log().Info(ctx, "TransactionDao ExecInsertSql length:", dimSqlDML.String())
	return
}

func (dao *TransactionDao) BatchExecSql(ctx context.Context, chainName string) (err error) {

	// 待执行的Value放在缓存里
	key := chainName + consts.BATCH_TRANSACTION_DATA_KEY
	result, err := g.Redis().Do(ctx, "HGETALL", key)
	if err != nil {
		return err
	}

	g.Log().Info(ctx, "TransactionDao ExecInsert length: 0")
	if len(result.Map()) > 0 {
		var sqlDML bytes.Buffer
		sqlDML.WriteString("insert into ")
		sqlDML.WriteString(chainName + "." + dao.table)
		sqlDML.WriteString(" (tx_hash, tx_index,height,contract_address,status,from,to,value,gas_used,gas_limit,gas_price,transaction_fee,create_time,update_time,timestamp) values  ")

		for rkey, val := range result.Map() {
			sql := val.(string)
			sqlDML.WriteString(sql + ",")
			//regexp, _ := regexp.Compile("[\\w]{66}")
			//txHash := regexp.FindString(sql)

			g.Redis().Do(ctx, "HDEL", key, rkey)
			if err != nil {
				continue
			}

			simpleTxCacheKey := chainName + "_tx_" + rkey
			g.Redis().Do(ctx, "SETEX", simpleTxCacheKey, 300, true)
			if err != nil {
				continue
			}
		}
		g.Log().Info(ctx, "TransactionDao ExecInsert length:", len(result.Map()), " ,sql length:", len(sqlDML.String()))
		_, err = dao.DB().Exec(ctx, sqlDML.String())
		if err != nil {
			g.Log().Debug(ctx, "TransactionDao ExecInsert error:", err)
			return err
		}
	}
	return nil
}
